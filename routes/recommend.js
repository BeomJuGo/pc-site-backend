// routes/recommend.js - Í∞úÏÑ†Îêú AI Ï∂îÏ≤ú ÏãúÏä§ÌÖú
import express from "express";
import { getDB } from "../db.js";

const router = express.Router();

/* ==================== Ïú†Ìã∏Î¶¨Ìã∞ Ìï®Ïàò ==================== */

// Î©îÎ™®Î¶¨ Ïö©Îüâ Ï∂îÏ∂ú (GB) - Í∞úÏÑ†Îê®
function extractMemoryCapacity(memory) {
  const text = `${memory.name || ""} ${memory.info || ""} ${memory.specSummary || ""}`.toUpperCase();
  
  // Îã§ÏñëÌïú Ìå®ÌÑ¥ ÏßÄÏõê
  const patterns = [
    /(\d+)\s*GB\s*\(/i,           // "32GB(16GBx2)" ÌòïÏãù
    /(\d+)\s*GB(?!\s*X)/i,        // "32GB" (XÍ∞Ä Îí§Ïóê ÏóÜÏùå)
    /GB\s*(\d+)/i,                // "GB 32" ÌòïÏãù
  ];
  
  for (const pattern of patterns) {
    const match = text.match(pattern);
    if (match) {
      const capacity = parseInt(match[1]);
      if (capacity >= 4 && capacity <= 256) { // Ïú†Ìö® Î≤îÏúÑ Ï≤¥ÌÅ¨
        return capacity;
      }
    }
  }
  
  // Í∏∞Î≥∏Í∞í Î∞òÌôò (ÌååÏã± Ïã§Ìå® Ïãú)
  console.warn(`‚ö†Ô∏è Î©îÎ™®Î¶¨ Ïö©Îüâ ÌååÏã± Ïã§Ìå®: ${memory.name}`);
  return 0;
}

// CPU ÏÜåÏºì Ï∂îÏ∂ú
function extractCpuSocket(cpu) {
  const text = `${cpu.name || ""} ${cpu.info || ""} ${cpu.specSummary || ""}`;
  const match = text.match(/(AM4|AM5|LGA\s*1700|LGA\s*1200|LGA\s*2066)/i);
  return match ? match[1].replace(/\s+/g, "").toUpperCase() : "";
}

// Î©îÏù∏Î≥¥Îìú ÏÜåÏºì Ï∂îÏ∂ú
function extractBoardSocket(board) {
  const text = `${board.name || ""} ${board.info || ""} ${board.specSummary || ""}`;
  const match = text.match(/(AM4|AM5|LGA\s*1700|LGA\s*1200|LGA\s*2066)/i);
  return match ? match[1].replace(/\s+/g, "").toUpperCase() : "";
}

// Î©îÎ™®Î¶¨ ÌÉÄÏûÖ Ï∂îÏ∂ú (DDR4/DDR5)
function extractDdrType(text = "") {
  const match = text.toUpperCase().match(/DDR([45])/);
  return match ? `DDR${match[1]}` : "";
}

// ÏºÄÏù¥Ïä§ ÌèºÌå©ÌÑ∞ Ï∂îÏ∂ú - Í∞úÏÑ†Îê®
function extractCaseFormFactors(caseItem) {
  const specs = caseItem.specs || {};
  let formFactors = specs.formFactor || [];
  
  // üÜï formFactorÍ∞Ä ÎπÑÏñ¥ÏûàÏúºÎ©¥ nameÍ≥º infoÏóêÏÑú Ï∂îÏ∂ú ÏãúÎèÑ
  if (formFactors.length === 0) {
    const combined = `${caseItem.name || ""} ${caseItem.info || ""}`.toUpperCase();
    
    if (/E-?ATX/i.test(combined)) formFactors.push("E-ATX");
    if (/ATX/i.test(combined) && !/MINI|MICRO|M-ATX/i.test(combined)) formFactors.push("ATX");
    if (/M-?ATX|MATX|MICRO\s*ATX/i.test(combined)) formFactors.push("mATX");
    if (/MINI-?ITX|ITX/i.test(combined)) formFactors.push("Mini-ITX");
  }
  
  // üÜï Ïó¨Ï†ÑÌûà ÎπÑÏñ¥ÏûàÏúºÎ©¥ ÏºÄÏù¥Ïä§ ÌÉÄÏûÖ Í∏∞Î∞ò Í∏∞Î≥∏Í∞í ÏÑ§Ï†ï
  if (formFactors.length === 0) {
    const type = (specs.type || "").toLowerCase();
    if (type.includes("ÎπÖÌÉÄÏõå") || type.includes("ÎØ∏Îì§ÌÉÄÏõå")) {
      formFactors = ["E-ATX", "ATX", "mATX", "Mini-ITX"]; // ÎåÄÎ∂ÄÎ∂Ñ ÏßÄÏõê
    } else if (type.includes("ÎØ∏ÎãàÌÉÄÏõå")) {
      formFactors = ["mATX", "Mini-ITX"];
    } else {
      formFactors = ["ATX", "mATX"]; // Í∏∞Î≥∏Í∞í
    }
    console.log(`‚ö†Ô∏è ÏºÄÏù¥Ïä§ ÌèºÌå©ÌÑ∞ Ï∂îÎ°†: ${caseItem.name} ‚Üí ${formFactors.join(", ")}`);
  }
  
  return formFactors;
}

// Î©îÏù∏Î≥¥Îìú ÌèºÌå©ÌÑ∞ Ï∂îÏ∂ú
function extractBoardFormFactor(board) {
  const text = `${board.name || ""} ${board.info || ""} ${board.specSummary || ""}`.toUpperCase();
  
  if (/E-?ATX/i.test(text)) return "E-ATX";
  if (/MINI-?ITX|ITX/i.test(text)) return "Mini-ITX";
  if (/M-?ATX|MATX|MICRO\s*ATX/i.test(text)) return "mATX";
  if (/ATX/i.test(text)) return "ATX";
  
  return "ATX"; // Í∏∞Î≥∏Í∞í
}

// ÌèºÌå©ÌÑ∞ Ìò∏ÌôòÏÑ± Ï≤¥ÌÅ¨ - Í∞úÏÑ†Îê®
function isFormFactorCompatible(board, caseItem) {
  const boardFormFactor = extractBoardFormFactor(board);
  const caseFormFactors = extractCaseFormFactors(caseItem);
  
  // üÜï ÏºÄÏù¥Ïä§Í∞Ä Ïó¨Îü¨ ÌèºÌå©ÌÑ∞Î•º ÏßÄÏõêÌïòÎäîÏßÄ ÌôïÏù∏
  const compatible = caseFormFactors.some(cf => {
    // Ï†ïÍ∑úÌôî
    const normalizedCase = cf.replace(/[-\s]/g, "").toUpperCase();
    const normalizedBoard = boardFormFactor.replace(/[-\s]/g, "").toUpperCase();
    
    // ÏßÅÏ†ë Îß§Ïπ≠
    if (normalizedCase === normalizedBoard) return true;
    
    // ÌïòÏúÑ Ìò∏ÌôòÏÑ± Ï≤¥ÌÅ¨ (ÌÅ∞ ÏºÄÏù¥Ïä§Îäî ÏûëÏùÄ Î≥¥Îìú ÏàòÏö©)
    const hierarchy = {
      "MINIITX": 1,
      "ITX": 1,
      "MATX": 2,
      "MICROATX": 2,
      "ATX": 3,
      "EATX": 4
    };
    
    const caseLevel = hierarchy[normalizedCase] || 3;
    const boardLevel = hierarchy[normalizedBoard] || 3;
    
    return caseLevel >= boardLevel;
  });
  
  if (!compatible) {
    console.log(`‚ùå ÌèºÌå©ÌÑ∞ Î∂àÏùºÏπò: ${board.name} (${boardFormFactor}) ‚Üî ${caseItem.name} (${caseFormFactors.join("/")})`);
  }
  
  return compatible;
}

// TDP/Ï†ÑÎ†• Ï∂îÏ∂ú
function extractTdp(text = "") {
  const match = text.match(/(\d+)\s*W/i);
  return match ? parseInt(match[1]) : 0;
}

// GPU Í∏∏Ïù¥ Ï∂îÏ∂ú
function extractGpuLength(gpu) {
  const text = `${gpu.name || ""} ${gpu.info || ""}`;
  const match = text.match(/(\d+)\s*mm/i);
  return match ? parseInt(match[1]) : 300; // Í∏∞Î≥∏Í∞í 300mm
}

// Ïø®Îü¨ ÎÜíÏù¥ Ï∂îÏ∂ú
function extractCoolerHeight(cooler) {
  const text = `${cooler.name || ""} ${cooler.info || ""}`;
  const match = text.match(/(\d+)\s*mm/i);
  return match ? parseInt(match[1]) : 150; // Í∏∞Î≥∏Í∞í 150mm
}

/* ==================== Ï∂îÏ≤ú Î°úÏßÅ ==================== */

router.post("/", async (req, res) => {
  try {
    const { budget, purpose } = req.body;
    
    if (!budget || budget < 500000) {
      return res.status(400).json({ message: "ÏµúÏÜå ÏòàÏÇ∞ÏùÄ 50ÎßåÏõêÏûÖÎãàÎã§." });
    }
    
    console.log(`\nüéØ Ï∂îÏ≤ú ÏöîÏ≤≠: ÏòàÏÇ∞ ${budget.toLocaleString()}Ïõê, Ïö©ÎèÑ: ${purpose}`);

    const db = getDB();
    const col = db.collection("parts");

    // üÜï 8Í∞ÄÏßÄ Î∂ÄÌíà Î™®Îëê Í∞ÄÏ†∏Ïò§Í∏∞
    const [cpus, gpus, memories, boards, psus, coolers, storages, cases] = await Promise.all([
      col.find({ category: "cpu", price: { $gt: 0 } }).toArray(),
      col.find({ category: "gpu", price: { $gt: 0 } }).toArray(),
      col.find({ category: "memory", price: { $gt: 0 } }).toArray(),
      col.find({ category: "motherboard", price: { $gt: 0 } }).toArray(),
      col.find({ category: "psu", price: { $gt: 0 } }).toArray(),
      col.find({ category: "cooler", price: { $gt: 0 } }).toArray(),
      col.find({ category: "storage", price: { $gt: 0 } }).toArray(),
      col.find({ category: "case", price: { $gt: 0 } }).toArray(),
    ]);

    console.log(`üì¶ Î∂ÄÌíà Í∞úÏàò: CPU(${cpus.length}), GPU(${gpus.length}), Memory(${memories.length}), Board(${boards.length}), PSU(${psus.length}), Cooler(${coolers.length}), Storage(${storages.length}), Case(${cases.length})`);

    // üÜï Í∞Å Ïπ¥ÌÖåÍ≥†Î¶¨Î≥Ñ ÏµúÏÜå Í∞úÏàò Ï≤¥ÌÅ¨
    if (cpus.length < 5 || gpus.length < 5 || memories.length < 5 || boards.length < 5) {
      return res.status(500).json({ 
        message: "Î∂ÄÌíà Îç∞Ïù¥ÌÑ∞Í∞Ä Î∂ÄÏ°±Ìï©ÎãàÎã§. Îç∞Ïù¥ÌÑ∞ ÎèôÍ∏∞ÌôîÎ•º Ïã§ÌñâÌï¥Ï£ºÏÑ∏Ïöî.",
        data: { cpus: cpus.length, gpus: gpus.length, memories: memories.length, boards: boards.length }
      });
    }

    // Ïö©ÎèÑÎ≥Ñ Ï†êÏàò Í∞ÄÏ§ëÏπò
    const scoreWeights = {
      "ÏÇ¨Î¨¥Ïö©": { cpu: 0.3, gpu: 0.1 },
      "Í≤åÏûÑÏö©": { cpu: 0.35, gpu: 0.45 },
      "ÏûëÏóÖÏö©": { cpu: 0.4, gpu: 0.4 },
      "Í∞ÄÏÑ±ÎπÑ": { cpu: 0.35, gpu: 0.35 },
    };
    const weights = scoreWeights[purpose] || scoreWeights["Í∞ÄÏÑ±ÎπÑ"];

    // CPU/GPU ÌõÑÎ≥¥ ÌïÑÌÑ∞ÎßÅ (Ïö©ÎèÑÎ≥Ñ)
    let cpuCand = cpus.filter(c => c.benchScore > 0);
    let gpuCand = gpus.filter(g => g.benchScore > 0);

    if (purpose === "ÏÇ¨Î¨¥Ïö©") {
      cpuCand = cpuCand.filter(c => c.price <= 300000);
      gpuCand = gpuCand.filter(g => g.price <= 200000);
    }

    // üÜï ÌõÑÎ≥¥ Í∞úÏàò Î°úÍπÖ
    console.log(`üîç ÌïÑÌÑ∞ÎßÅ ÌõÑ: CPU(${cpuCand.length}), GPU(${gpuCand.length})`);

    // ÏÑ±Îä• Ï†êÏàò Í≥ÑÏÇ∞
    const topCPUs = cpuCand
      .sort((a, b) => (b.benchScore / b.price) - (a.benchScore / a.price))
      .slice(0, 30); // 20 ‚Üí 30ÏúºÎ°ú Ï¶ùÍ∞Ä
    
    const topGPUs = gpuCand
      .sort((a, b) => (b.benchScore / b.price) - (a.benchScore / a.price))
      .slice(0, 30); // 20 ‚Üí 30ÏúºÎ°ú Ï¶ùÍ∞Ä

    console.log(`‚ú® ÏÉÅÏúÑ ÌõÑÎ≥¥: CPU(${topCPUs.length}), GPU(${topGPUs.length})`);

    const results = [];
    const compatibilityFails = {
      socket: 0,
      ddr: 0,
      formFactor: 0,
      power: 0,
      gpu: 0,
      cooler: 0,
      memory: 0,
      total: 0
    };

    // Ï°∞Ìï© ÏÉùÏÑ±
    for (const cpu of topCPUs) {
      for (const gpu of topGPUs) {
        const baseCost = cpu.price + gpu.price;
        const remaining = budget - baseCost;
        
        if (remaining < 100000) continue; // ÏµúÏÜå 10ÎßåÏõêÏùÄ ÎÇ®ÏïÑÏïº Ìï®

        const cpuSocket = extractCpuSocket(cpu);
        const cpuDdr = extractDdrType(cpu.info || cpu.specSummary || "");
        const cpuTdp = extractTdp(cpu.info || cpu.specSummary || "");
        const gpuTdp = extractTdp(gpu.info || "");
        const totalTdp = cpuTdp + gpuTdp + 100; // Í∏∞ÌÉÄ Î∂ÄÌíà 100W
        const gpuLength = extractGpuLength(gpu);

        // Î©îÏù∏Î≥¥Îìú Ìò∏Ìôò ÌïÑÌÑ∞ÎßÅ
        const boardCand = boards.filter(b => {
          const bSocket = extractBoardSocket(b);
          const bDdr = extractDdrType(b.info || b.specSummary || "");
          
          const socketMatch = !cpuSocket || !bSocket || bSocket === cpuSocket;
          const ddrMatch = !cpuDdr || !bDdr || bDdr === cpuDdr;
          
          if (!socketMatch) compatibilityFails.socket++;
          if (!ddrMatch) compatibilityFails.ddr++;
          
          return socketMatch && ddrMatch && b.price <= remaining * 0.25;
        });

        if (boardCand.length === 0) continue;

        for (const board of boardCand.slice(0, 20)) { // 15 ‚Üí 20ÏúºÎ°ú Ï¶ùÍ∞Ä
          const boardDdr = extractDdrType(board.info || board.specSummary || "");

          // Î©îÎ™®Î¶¨ ÌïÑÌÑ∞ÎßÅ - Í∞úÏÑ†Îê®
          const memCand = memories.filter(m => {
            const mDdr = extractDdrType(m.name || m.info || "");
            const capacity = extractMemoryCapacity(m);
            
            // üÜï DDR ÌÉÄÏûÖ Îß§Ïπ≠ ÏôÑÌôî
            const ddrMatch = !boardDdr || !mDdr || mDdr === boardDdr;
            
            // üÜï Ïö©Îüâ Ï≤¥ÌÅ¨ Í∞úÏÑ†
            const validCapacity = capacity >= 8; // ÏµúÏÜå 8GB
            
            if (!ddrMatch) compatibilityFails.ddr++;
            if (!validCapacity) compatibilityFails.memory++;
            
            return ddrMatch && validCapacity && m.price <= remaining * 0.15;
          });

          // üÜï Î©îÎ™®Î¶¨ ÌõÑÎ≥¥ Î°úÍπÖ
          if (memCand.length === 0) {
            console.log(`‚ö†Ô∏è Î©îÎ™®Î¶¨ ÌõÑÎ≥¥ 0Í∞ú: Board DDR=${boardDdr}, ÏòàÏÇ∞=${(remaining * 0.15).toLocaleString()}Ïõê`);
            continue;
          }

          for (const memory of memCand.slice(0, 15)) { // 10 ‚Üí 15Î°ú Ï¶ùÍ∞Ä
            const memCapacity = extractMemoryCapacity(memory);

            // PSU ÌïÑÌÑ∞ÎßÅ
            const psuCand = psus.filter(p => {
              const psuWattage = extractTdp(p.name || p.info || "");
              const sufficient = psuWattage >= totalTdp * 1.2; // 20% Ïó¨Ïú†
              
              if (!sufficient) compatibilityFails.power++;
              
              return sufficient && p.price <= remaining * 0.12;
            });

            if (psuCand.length === 0) continue;

            for (const psu of psuCand.slice(0, 12)) { // 10 ‚Üí 12Î°ú Ï¶ùÍ∞Ä
              // Cooler ÌïÑÌÑ∞ÎßÅ
              const coolerCand = coolers.filter(c => c.price <= remaining * 0.08);
              if (coolerCand.length === 0) continue;

              for (const cooler of coolerCand.slice(0, 12)) { // 10 ‚Üí 12Î°ú Ï¶ùÍ∞Ä
                const coolerHeight = extractCoolerHeight(cooler);

                // Storage ÌïÑÌÑ∞ÎßÅ
                const storageCand = storages.filter(s => s.price <= remaining * 0.12);
                if (storageCand.length === 0) continue;

                for (const storage of storageCand.slice(0, 10)) { // 8 ‚Üí 10ÏúºÎ°ú Ï¶ùÍ∞Ä
                  // Case ÌïÑÌÑ∞ÎßÅ - Í∞úÏÑ†Îê®
                  const caseCand = cases.filter(c => {
                    // ÌèºÌå©ÌÑ∞ Ï≤¥ÌÅ¨
                    const formFactorOk = isFormFactorCompatible(board, c);
                    
                    // GPU Í∏∏Ïù¥ Ï≤¥ÌÅ¨
                    const caseSpecs = c.specs || {};
                    const maxGpuLen = caseSpecs.maxGpuLength || 400;
                    const gpuFits = gpuLength <= maxGpuLen;
                    
                    // Ïø®Îü¨ ÎÜíÏù¥ Ï≤¥ÌÅ¨
                    const maxCoolerHeight = caseSpecs.maxCpuCoolerHeight || 180;
                    const coolerFits = coolerHeight <= maxCoolerHeight;
                    
                    if (!formFactorOk) compatibilityFails.formFactor++;
                    if (!gpuFits) compatibilityFails.gpu++;
                    if (!coolerFits) compatibilityFails.cooler++;
                    
                    return formFactorOk && gpuFits && coolerFits && c.price <= remaining * 0.1;
                  });

                  if (caseCand.length === 0) continue;

                  for (const caseItem of caseCand.slice(0, 10)) { // 8 ‚Üí 10ÏúºÎ°ú Ï¶ùÍ∞Ä
                    const totalPrice =
                      cpu.price +
                      gpu.price +
                      memory.price +
                      board.price +
                      psu.price +
                      cooler.price +
                      storage.price +
                      caseItem.price;

                    if (totalPrice > budget) continue;

                    const score =
                      cpu.benchScore * weights.cpu +
                      gpu.benchScore * weights.gpu;

                    results.push({
                      cpu,
                      gpu,
                      memory,
                      board,
                      psu,
                      cooler,
                      storage,
                      case: caseItem,
                      totalPrice,
                      score,
                      compatibility: {
                        socket: `${cpuSocket} ‚Üî ${extractBoardSocket(board)}`,
                        ddr: `${cpuDdr || boardDdr} ‚Üî ${extractDdrType(memory.name)}`,
                        power: `${totalTdp}W ‚Üí ${extractTdp(psu.name)}W`,
                        formFactor: `${extractBoardFormFactor(board)} ‚Üí ${extractCaseFormFactors(caseItem).join("/")}`,
                      },
                    });
                  }
                }
              }
            }
          }
        }
      }
    }

    // üÜï Ìò∏ÌôòÏÑ± Ïã§Ìå® ÌÜµÍ≥Ñ Î°úÍπÖ
    console.log(`\nüìä Ìò∏ÌôòÏÑ± Ï≤¥ÌÅ¨ Ïã§Ìå® ÌÜµÍ≥Ñ:`);
    console.log(`   ÏÜåÏºì Î∂àÏùºÏπò: ${compatibilityFails.socket}Ìöå`);
    console.log(`   DDR Î∂àÏùºÏπò: ${compatibilityFails.ddr}Ìöå`);
    console.log(`   ÌèºÌå©ÌÑ∞ Î∂àÏùºÏπò: ${compatibilityFails.formFactor}Ìöå`);
    console.log(`   Ï†ÑÎ†• Î∂ÄÏ°±: ${compatibilityFails.power}Ìöå`);
    console.log(`   GPU Í∏∏Ïù¥ Ï¥àÍ≥º: ${compatibilityFails.gpu}Ìöå`);
    console.log(`   Ïø®Îü¨ ÎÜíÏù¥ Ï¥àÍ≥º: ${compatibilityFails.cooler}Ìöå`);
    console.log(`   Î©îÎ™®Î¶¨ Ïö©Îüâ Î¨∏Ï†ú: ${compatibilityFails.memory}Ìöå`);

    console.log(`\nüéâ Ï°∞Ìï© ÏÉùÏÑ± ÏôÑÎ£å: ${results.length}Í∞ú`);

    if (results.length === 0) {
      return res.status(404).json({
        message: "‚ö†Ô∏è ÏòàÏÇ∞Í≥º Ìò∏Ìôò Ï°∞Í±¥Ïóê ÎßûÎäî Ï°∞Ìï©ÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§. ÏòàÏÇ∞ÏùÑ ÎäòÎ¶¨Í±∞ÎÇò Ï°∞Í±¥ÏùÑ ÏôÑÌôîÌï¥Ï£ºÏÑ∏Ïöî.",
        debug: {
          budget: budget.toLocaleString(),
          purpose,
          candidates: {
            cpu: topCPUs.length,
            gpu: topGPUs.length,
            memory: memories.length,
            board: boards.length,
            psu: psus.length,
            cooler: coolers.length,
            storage: storages.length,
            case: cases.length,
          },
          compatibilityFails,
        },
      });
    }

    // ÏÉÅÏúÑ 3Í∞ú ÏÑ†ÌÉù (Í∞ÄÏÑ±ÎπÑ/Í∑†Ìòï/Í≥†ÏÑ±Îä•)
    results.sort((a, b) => b.score - a.score);

    const costEfficient = results
      .slice()
      .sort((a, b) => b.score / b.totalPrice - a.score / a.totalPrice)[0];
    
    const balanced = results[Math.floor(results.length / 2)];
    const highPerf = results[0];

    const builds = [
      { label: "Í∞ÄÏÑ±ÎπÑ", ...costEfficient },
      { label: "Í∑†Ìòï", ...balanced },
      { label: "Í≥†ÏÑ±Îä•", ...highPerf },
    ];

    // Ï∂îÏ≤ú Í∑ºÍ±∞
    const reasons = [
      `${purpose} Ïö©ÎèÑÏóê ÏµúÏ†ÅÌôîÎêú ${builds[1].cpu.name} CPU ÏÇ¨Ïö©`,
      `ÏòàÏÇ∞ ${budget.toLocaleString()}Ïõê ÎÇ¥ÏóêÏÑú ${builds.length}Í∞ÄÏßÄ Ï°∞Ìï© Ï∂îÏ≤ú`,
      `Ï†ÑÎ†• ${builds[1].compatibility.power} ÏïàÏ†ïÏ†Å Í≥µÍ∏â`,
      `${builds[1].compatibility.socket} ÏÜåÏºì ÏôÑÎ≤Ω Ìò∏Ìôò`,
    ];

    res.json({
      builds: builds.map(b => ({
        label: b.label,
        totalPrice: b.totalPrice,
        score: Math.round(b.score),
        parts: {
          cpu: { name: b.cpu.name, price: b.cpu.price, image: b.cpu.image },
          gpu: { name: b.gpu.name, price: b.gpu.price, image: b.gpu.image },
          memory: { name: b.memory.name, price: b.memory.price, image: b.memory.image },
          motherboard: { name: b.board.name, price: b.board.price, image: b.board.image },
          psu: { name: b.psu.name, price: b.psu.price, image: b.psu.image },
          cooler: { name: b.cooler.name, price: b.cooler.price, image: b.cooler.image },
          storage: { name: b.storage.name, price: b.storage.price, image: b.storage.image },
          case: { name: b.case.name, price: b.case.price, image: b.case.image },
        },
        compatibility: b.compatibility,
        reasons,
      })),
      recommended: builds[1].label,
      message: `${purpose} Ïö©ÎèÑÎ°ú ${builds.length}Í∞ÄÏßÄ Ï°∞Ìï©ÏùÑ Ï∂îÏ≤úÌï©ÎãàÎã§!`,
    });

  } catch (error) {
    console.error("‚ùå Ï∂îÏ≤ú Ïò§Î•ò:", error);
    res.status(500).json({ message: "Ï∂îÏ≤ú Ï§ë Ïò§Î•ò Î∞úÏÉù", error: error.message });
  }
});

export default router;
