// routes/syncMEMORY.js
import express from "express";
import axios from "axios";
import * as cheerio from "cheerio";
import { getDB } from "../db.js";

const router = express.Router();

const ORIGIN = "https://versus.com";
const LIST_URL = (p) => `${ORIGIN}/en/memory?page=${p}`;
const sleep = (ms) => new Promise((r) => setTimeout(r, ms));

/* ------------------------------------ */
/* HTTP ÏöîÏ≤≠ Ïú†Ìã∏                        */
/* ------------------------------------ */
async function fetchHtml(url, tryCount = 0) {
  try {
    const res = await axios.get(url, {
      timeout: 20000,
      headers: {
        "User-Agent":
          "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124 Safari/537.36",
        "Accept-Language": "en-US,en;q=0.9",
        Accept: "text/html,application/xhtml+xml",
        Referer: ORIGIN,
      },
    });
    return res.data;
  } catch (e) {
    if (tryCount < 2) {
      console.log(`‚ö†Ô∏è Ïû¨ÏãúÎèÑ(${tryCount + 1}) ‚Üí ${url}`);
      await sleep(1000 + 300 * tryCount);
      return fetchHtml(url, tryCount + 1);
    }
    console.log(`‚ùå ÏöîÏ≤≠ Ïã§Ìå®: ${url} (${e?.response?.status || e.message})`);
    return null;
  }
}

/* ------------------------------------ */
/* Î¶¨Ïä§Ìä∏ ÌõÑÎ≥¥ ÌåêÎ≥Ñ/ÏàòÏßë                 */
/* ------------------------------------ */
function isOneLevelProductHref(href) {
  if (!href?.startsWith("/en/")) return false;
  if (href.startsWith("/en/memory/")) return false;   // ÌóàÎ∏å/Í∞ÄÏù¥Îìú Ï†úÏô∏
  if (href.startsWith("/en/compare/")) return false;  // ÎπÑÍµê ÌéòÏù¥ÏßÄ Ï†úÏô∏
  const path = href.split("?")[0];
  const parts = path.split("/").filter(Boolean); // ["en","slug"]
  return parts.length === 2; // Ï†ïÌôïÌûà /en/<slug> ‚Üí Ï†úÌíà ÌõÑÎ≥¥
}

function extractProductCandidates($) {
  const candidates = new Set();
  $('a[href^="/en/"]').each((_, a) => {
    const href = $(a).attr("href");
    if (!isOneLevelProductHref(href)) return;
    const abs = href.startsWith("http") ? href : `${ORIGIN}${href.split("?")[0]}`;
    candidates.add(abs);
  });
  return Array.from(candidates);
}

/* ------------------------------------ */
/* Ïù¥Î¶Ñ/Ïä§Ìéô Ï†ïÏ†ú                        */
/* ------------------------------------ */
function cleanProductName(nameRaw = "") {
  let name = (nameRaw || "")
    .replace(/\s+/g, " ")
    .replace(/[\u2013\u2014]/g, "-") // ‚Äì ‚Äî ‚Üí -
    .trim();

  // 1) ÌùîÌïú Íº¨Î¶¨Ìëú/Íµ¨Î∂ÑÏûê Ìå®ÌÑ¥Îì§ÏùÑ Í≥ºÍ∞êÌûà Ï†úÍ±∞
  //   Ïòà: "‚Ä¶ review: specs and price", "‚Ä¶ specs and price", "‚Ä¶ price and specs", "‚Ä¶ full specs"
  name = name.replace(/\s*[-‚Äì‚Äî:|]?\s*review[:\s].*$/i, "");
  name = name.replace(/\s*[-‚Äì‚Äî:|]?\s*specs?\s*(and|&)\s*price.*$/i, "");
  name = name.replace(/\s*[-‚Äì‚Äî:|]?\s*price\s*(and|&)\s*specs?.*$/i, "");
  name = name.replace(/\s*[-‚Äì‚Äî:|]?\s*full\s*specs?.*$/i, "");
  name = name.replace(/\s*[-‚Äì‚Äî:|]?\s*features\s*and\s*specs?.*$/i, "");

  // 2) ÎπÑÍµê/ÎåÄÏÉÅ ÌëúÍ∏∞ Ï†úÍ±∞
  name = name.replace(/\s*[-‚Äì‚Äî:|]?\s*vs\s+.*$/i, "");
  name = name.replace(/\s*[-‚Äì‚Äî:|]?\s*versus\s+.*$/i, "");

  // 3) ÏÇ¨Ïù¥Ìä∏ Î∏åÎûúÎî© Íº¨Î¶¨Ìëú Ï†úÍ±∞ (on Versus, | Versus Îì±)
  name = name.replace(/\s*[-‚Äì‚Äî:|]?\s*on\s+versus\s*$/i, "");
  name = name.replace(/\s*[-‚Äì‚Äî:|]?\s*versus\s*$/i, "");
  name = name.replace(/\s*[-‚Äì‚Äî:|]?\s*\|\s*versus\s*$/i, "");
  name = name.replace(/\s*[-‚Äì‚Äî:|]?\s*‚Äì\s*versus\s*$/i, "");

  // 4) Îí§Ïóê Î∂ôÏùÄ Î∂àÌïÑÏöîÌïú Í¥ÑÌò∏/Íµ¨Î¨∏ Ï†ïÎ¶¨(ÎÑàÎ¨¥ Í≥µÍ≤©Ï†ÅÏù¥ÏßÄ ÏïäÍ≤å Í≥µÎ∞± Ïû¨Ï†ïÎ¶¨)
  name = name.replace(/\s+/g, " ").trim();
  return name;
}

/** ÌÖçÏä§Ìä∏ Îç©Ïñ¥Î¶¨ÏóêÏÑú Î©îÎ™®Î¶¨ Ïä§Ìéô Ï∂îÏ∂ú ‚Üí info Î¨∏ÏûêÏó¥ ÏÉùÏÑ± (Type/Speed/Capacity/CL) */
function buildMemoryInfoFromText(str) {
  if (!str) return "";

  const typeMatch = str.match(/\b(DDR[2-5])\b/i);                  // DDR4, DDR5
  const speedMatch =
    str.match(/\b(\d{4,5})\s*MHz\b/i) ||                          // 3200 MHz, 6000 MHz
    str.match(/\b(\d{4,5})\s*MT\/s\b/i) ||                        // 6400 MT/s
    str.match(/\bDDR[2-5]-?(\d{3,5})\b/i);                        // DDR5-6400
  const kitMatch =
    str.match(/\b(\d{1,2})\s*x\s*(\d{1,3})\s*GB\b/i) ||           // 2x16 GB
    str.match(/\b(\d{1,3})\s*GB\s*\(\s*(\d{1,2})\s*x\s*(\d{1,3})\s*GB\)/i); // 32GB (2x16GB)
  const capacityMatch = str.match(/\b(\d{1,3})\s*GB\b/i);         // 32GB
  const clMatch =
    str.match(/\bCL\s*([0-9]{1,2})\b/i) ||
    str.match(/\bCAS\s*Latency\s*([0-9]{1,2})\b/i);

  const type = typeMatch ? typeMatch[1].toUpperCase() : "";
  const speed = speedMatch ? speedMatch[1] : "";

  let capacity = "";
  if (kitMatch) {
    const a = parseInt(kitMatch[1], 10);
    const b = parseInt(kitMatch[2], 10);
    if (!isNaN(a) && !isNaN(b)) {
      capacity = `${a}x${b}GB (${a * b}GB)`;
    }
  } else if (capacityMatch) {
    capacity = `${capacityMatch[1]}GB`;
  }

  const cl = clMatch ? clMatch[1] : "";

  const parts = [];
  if (type) parts.push(`Type: ${type}`);
  if (speed) parts.push(`Speed: ${speed} MHz`);
  if (capacity) parts.push(`Capacity: ${capacity}`);
  if (cl) parts.push(`CL: ${cl}`);
  return parts.join(", ");
}

/* ------------------------------------ */
/* ÏÉÅÏÑ∏ ÌéòÏù¥ÏßÄ ÌååÏÑú                      */
/* ------------------------------------ */
function extractProductName($) {
  const h1 = $("h1").first().text().trim();
  if (h1) return cleanProductName(h1);

  const og = $('meta[property="og:title"]').attr("content");
  if (og) return cleanProductName(og);

  const title = $("title").text().trim();
  return cleanProductName(title || "");
}

/** Ìëú/ÎùºÎ≤®/JSON-LD/Î≥∏Î¨∏ÏóêÏÑú info Íµ¨ÏÑ± */
function extractMemoryInfo($) {
  // 1) Ìëú Í∏∞Î∞ò
  const rows = [];
  $("table tr").each((_, tr) => {
    const k = $(tr).find("th,td").first().text().trim();
    const v = $(tr).find("td,th").eq(1).text().trim();
    if (k && v) rows.push(`${k}: ${v}`);
  });
  let info = buildMemoryInfoFromText(rows.join(" | "));
  if (info) return info;

  // 2) ÎùºÎ≤®/Ï†ïÏùò/Ïπ¥ÎìúÌòï/ÏûêÏú† ÌÖçÏä§Ìä∏
  const blocks = [];
  $('li, div, section, p, span, dt, dd').each((_, el) => {
    const t = $(el).text().trim();
    if (t) blocks.push(t);
  });
  info = buildMemoryInfoFromText(blocks.slice(0, 150).join(" | "));
  if (info) return info;

  // 3) JSON-LD
  $('script[type="application/ld+json"]').each((_, s) => {
    try {
      const t = $(s).contents().text();
      const j = JSON.parse(t);
      const texts = [];
      if (Array.isArray(j)) j.forEach(x => texts.push(x?.name, x?.description));
      else texts.push(j?.name, j?.description);
      const str = texts.filter(Boolean).join(" ");
      const candidate = buildMemoryInfoFromText(str);
      if (candidate) { info = candidate; throw new Error("_break_"); }
    } catch (e) {
      if (e.message === "_break_") return false;
    }
  });
  if (info) return info;

  // 4) ÏµúÌõÑ: Î≥∏Î¨∏ Ï†ÑÏ≤¥
  const full = $("body").text().replace(/\s+/g, " ").trim();
  return buildMemoryInfoFromText(full);
}

/* ------------------------------------ */
/* ÏàòÏßë/Ï†ÄÏû• Î°úÏßÅ                        */
/* ------------------------------------ */
async function collectCandidates(pages = 2) {
  const out = new Set();
  for (let p = 1; p <= pages; p++) {
    const url = LIST_URL(p);
    console.log(`üîé Î¶¨Ïä§Ìä∏ ÌéòÏù¥ÏßÄ: ${url}`);
    const html = await fetchHtml(url);
    if (!html) { console.log("‚õî Î¶¨Ïä§Ìä∏ HTML ÏóÜÏùå"); continue; }
    const $ = cheerio.load(html);
    const found = extractProductCandidates($);
    console.log(`üìÉ ÌõÑÎ≥¥ ÏàòÏßë: ${found.length}Í±¥`);
    found.forEach(u => out.add(u));
    await sleep(500);
  }
  console.log(`‚úÖ Ï§ëÎ≥µÏ†úÍ±∞ ÌõÑ ÌõÑÎ≥¥ Ìï©Í≥Ñ: ${out.size}Í±¥`);
  return Array.from(out);
}

async function parseDetail(u) {
  const html = await fetchHtml(u);
  if (!html) return null;
  const $ = cheerio.load(html);

  const name = extractProductName($);
  if (!name) { console.log(`‚õî Ïù¥Î¶Ñ ÎØ∏Î∞úÍ≤¨: ${u}`); return null; }

  const info = extractMemoryInfo($);
  console.log(`üî¨ ÌååÏã±: name="${name}", info="${info}", url=${u}`);
  if (!info) console.log(`‚ö†Ô∏è Î©îÎ™®Î¶¨ info ÎØ∏Î∞úÍ≤¨: ${u}`);

  return { name, info };
}

async function saveToDB(list) {
  const db = getDB();
  const col = db.collection("parts");
  const existing = await col.find({ category: "memory" }).toArray();
  const byName = new Map(existing.map(x => [x.name, x]));

  for (const it of list) {
    const old = byName.get(it.name);
    const update = { category: "memory", info: it.info || "" };

    if (old) {
      await col.updateOne({ _id: old._id }, { $set: update });
      console.log(`üîÅ ÏóÖÎç∞Ïù¥Ìä∏: ${it.name} | ${it.info || "‚Äî"}`);
    } else {
      await col.insertOne({ name: it.name, ...update, priceHistory: [] });
      console.log(`üÜï ÏÇΩÏûÖ: ${it.name} | ${it.info || "‚Äî"}`);
    }
    await sleep(180);
  }
}

/* ------------------------------------ */
/* Í≥ºÍ±∞ Î¨∏ÏÑú Ï†ïÎ¶¨ (Ïù¥Î¶Ñ Íº¨Î¶¨Ìëú Ï†úÍ±∞)     */
/* ------------------------------------ */
function cleanupName(name = "") {
  return cleanProductName(name);
}
function cleanupInfo(info = "") {
  // infoÎäî Ïù¥ÎØ∏ Type/Speed/Capacity/CLÎßå Ï∂îÏ∂úÌï¥ ÎßåÎì† ÌòïÌÉúÎùº
  // Íµ≥Ïù¥ Îã§Ïãú ÌååÏã±Ìï† ÌïÑÏöîÍ∞Ä ÏóÜÏßÄÎßå, ÌòπÏãú Ïì∏Îç∞ÏóÜÎäî ÌÖçÏä§Ìä∏Í∞Ä ÏÑûÏòÄÏúºÎ©¥ ÏµúÏÜå Ï†ïÎ¶¨
  if (typeof info !== "string") return "";
  return info.replace(/\s+/g, " ").trim();
}

async function cleanupOldMemoryDocs() {
  const db = getDB();
  const col = db.collection("parts");
  const docs = await col.find({ category: "memory" }).toArray();

  let renamed = 0, reinfo = 0;
  for (const d of docs) {
    const newName = cleanupName(d.name);
    const newInfo = cleanupInfo(d.info);

    const set = {};
    if (newName && newName !== d.name) { set.name = newName; renamed++; }
    if (typeof d.info === "string" && newInfo !== d.info) { set.info = newInfo; reinfo++; }

    if (Object.keys(set).length > 0) {
      await col.updateOne({ _id: d._id }, { $set: set });
      console.log(`üßπ Ï†ïÎ¶¨Îê®: ${d._id} | name:"${d.name}"‚Üí"${set.name ?? d.name}" | info:"${d.info}"‚Üí"${set.info ?? d.info}"`);
    }
  }
  return { renamed, reinfo, total: docs.length };
}

/* ------------------------------------ */
/* ÎùºÏö∞ÌÑ∞                                */
/* ------------------------------------ */

// ÌÅ¨Î°§ÎßÅ & Ï†ÄÏû•
// POST /api/sync-memory
// body: { pages?: number, limit?: number }
router.post("/sync-memory", async (req, res) => {
  try {
    const pages = Number(req?.body?.pages) || 2;
    const hardLimit = Number(req?.body?.limit) || 60;

    res.json({ message: `‚úÖ Î©îÎ™®Î¶¨ ÎèôÍ∏∞Ìôî ÏãúÏûë (pages=${pages}, limit=${hardLimit})` });

    setImmediate(async () => {
      const cand = await collectCandidates(pages);
      const picked = [];
      for (const u of cand.slice(0, hardLimit)) {
        const parsed = await parseDetail(u);
        if (!parsed) continue;
        picked.push(parsed);
        await sleep(350);
      }

      if (picked.length === 0) {
        console.log("‚õî Ï†ÄÏû•Ìï† Ìï≠Î™© ÏóÜÏùå (ÌõÑÎ≥¥ 0)");
        return;
      }

      await saveToDB(picked);
      console.log("üéâ Î©îÎ™®Î¶¨ Ï†ÄÏû• ÏôÑÎ£å");
    });
  } catch (err) {
    console.error("‚ùå sync-memory Ïã§Ìå®", err);
    res.status(500).json({ error: "sync-memory Ïã§Ìå®" });
  }
});

// Í≥ºÍ±∞ Îç∞Ïù¥ÌÑ∞ Ï†ïÎ¶¨ (Ïù¥Î¶Ñ Íº¨Î¶¨Ìëú Ï†úÍ±∞)
// POST /api/cleanup-memory
router.post("/cleanup-memory", async (req, res) => {
  try {
    const result = await cleanupOldMemoryDocs();
    res.json({ message: "‚úÖ Ï†ïÎ¶¨ ÏôÑÎ£å", ...result });
  } catch (err) {
    console.error("‚ùå cleanup-memory Ïã§Ìå®", err);
    res.status(500).json({ error: "cleanup-memory Ïã§Ìå®" });
  }
});

export default router;
